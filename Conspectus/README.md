## Клиентская и Серверная модели X Window System-ы

> Основная цель Иксов - ГИБКОСТЬ
>> Идея типа в том, что как это выглядит - одно, но как оно работает - это другое
Таким образом на низком уровне предоставляються инструменты:
- необходимые, для рисования окон
- для обработки пользовательского ввода
- для рисования графики, с сипользование цветных (или черно-белых экранов) ну и т.д.
В этой точке было решено разделить систему на две части.
- `Клиент`, который решает, что делать И
- `Сервер`, который на самом деле 
    - рисует на экране,
    - читает пользовательский ввод,
    - отправляет его клиенту для обработки.

Эта модель, является полной противоположностью той, которая используеться при работе с `клиентами` и `серверами`.
В нашем случае пользователь садиться рядом с машиной, управляемой `сервером`, в то время как `клиент` может работать на удаленной машине.
`Сервер` управляет Экраном, Мышью и Клавиатурой.
- `Клиент` может: 
    - Подключаться к `Серверу`. 
	- Попросить, что бы `Сервер` нарисовал у себя на маниторе окно.
	- Попросить, что бы `Сервер` отправил ему любой ввод, который пользователь вводит с помощью клавиатуры или мыши в эти отрисованные окна

- Таким образом, несколько `Клиентов` могут подключиться к одному `Х-серверу`:
    - Один пожет работать с почтовыми программным обеспечением
    - Другой с браузером
    - Третий еще с чем то... и.т.д.

Когда что то вводится и посылаеться пользователем в какое то окно, Сервер отправляет сообщение клиенту, управляющему этим окном для обработки.
Клиент решает, что делать с этим вводом и отправляет серверу команды на отрисовку окна, ну или чего то другого...

Весь сеанс выполняеться с использованием протокола `Х-сообщений` (X message protocol)
Этот протокол был изночально разработан на протоколах TCP/IP, позволяющий клиенту работать на любом компьютере, подключенном к той же сети что и Сервер.
Позже `Х-серверы` были расширены, что бы позволить клиентам, работающим на локальном компьютере. иметь более оптимизированный доступ к серверу, например, с использованием общей памяти или с использованием сокета доменов Unix (это типа метод создания логического канала внутри системы Unix между двумя процессами)

---
## GUI программирование - модель асинхронного программирования
В отличие от обычных компьютерных программ, которые носят некоторы последовательных характер, программа с Графическим Интерфейсом обычно использует модель асинхронного программирования, программирование на основе событий. Это значит, что эта программа в основном бездействует ожидая событий отправленных Х-сервером, затем обробатывает поступившие события.

**Событие может быть таким:**
- пользователь нажал первую кнопку мыши (левую) в точке с координатами х, у
- Необходимо перерисовать окно, которым вы управляете

Чтобы программа реагировала на ввод пользователя, а также обновляла запросы, ей необходимо обрабатывать каждое событие за довольно короткий период времени (например, менее 200 миллисекунд, как правило).

Это также подразумевает, что программа может не выполнять операции, которые могут занимать много времени при обработке события (например, открытие сетевого подключения к какому-либо удаленному серверу, подключение к серверу базы данных или даже выполнение длительной операции копирования файла).
Вместо этого он должен выполнять все эти операции в асинхронном режиме.
Это может быть сделано с помощью различных асинхронных моделей для выполнения длинных операций или путем их выполнения в другом процессе или потоке.

Итак, внешний вид программы с графическим интерфейсом выглядит примерно так:
1. Выполнить процедуры инициализации.
2. Подключиться к `X-серверу`.
3. Выполните инициализацию.
4. Пока не закончено:
    1. Получите следующее событие от `X-сервера`.
    2. Обрабатывать событие, возможно отправляя различные запросы на рисование на `X-сервер`.
    3. Если событие было сообщением о выходе, выйдите из цикла.
5. Закройте соединение с `X-сервером`.
6. Выполните операции очистки.
---
## Основные понятия Xlib

Чтобы исключить необходимость в программах для реализации уровня протокола X, была создана библиотека под названием `Xlib`. Эта библиотека предоставляет программе очень низкоуровневый доступ к любому `X-серверу`.Поскольку протокол стандартизирован, клиент, использующий любую реализацию `Xlib`, может общаться с любым `X-сервером`. В наши дни это может показаться тривиальным, но в те дни, когда использовались терминалы в символьном режиме и собственные методы рисования графики на экранах, это выглядело как серьезный прорыв. В наше время мы видим большой хайп вокруг тонких клиентов, терминальных серверов `Х Window` и подобных систем. Сегодня эти системы реализуют то, что протокол X включил в конце 80-х годов.


### X Display

Основным понятием использования `Xlib` является `X display`. Это структура, представляющая соединение, которым мы открыли с данный `X-сервер`. Он скрывает очередь сообщений, поступающих с сервера, и очередь ожидающих запросов, которые наш клиент намеревается отправить на сервер. В `Xlib` эта структура называется `Display`. Когда мы открываем соединение с `X-сервером`, библиотека возвращает указатель на такую структуру. Далее мы предоставляем этот указатель для функций `Xlib`, которые должны отправлять сообщения на `X-сервер` или получать сообщения с этого сервера.

### GC - графический контекст

Когда мы выполняем различные операции рисования (графика, текст и т. д.), Мы можем указывать различные параметры для управления способом рисования данных - какие цвета переднего плана и фона использовать, как будут соединяться края линий, какой шрифт использовать при рисовании некоторого текста и т. д.).

Чтобы избежать необходимости предоставлять миллионы параметров для каждой функции рисования, используется структура графического контекста типа `GC`.

Мы устанавливаем различные параметры рисования в этой структуре, а затем передаем указатель на эту структуру функциям рисования. Это довольно удобно, так как нам часто приходится выполнять несколько запросов на рисование с одинаковыми параметрами. Таким образом, мы инициализируем графический контекст, устанавливаем желаемые параметры и передаем эту структуру GC всем функциям рисования.

### Дескрипторы объектов (Object Handles)

Когда X-сервер создает для нас различные объекты, такие как окна, области рисования и курсоры, соответствующая функция возвращает дескриптор. Это некоторый идентификатор объекта, который фактически находится в памяти X-сервера, а не в памяти нашего приложения. Позже мы можем манипулировать этим объектом, предоставляя этот дескриптор различным функциям Xlib. Сервер сохраняет соответствие между этими дескрипторами и фактическими объектами, которыми он управляет. Xlib предоставляет различные определения типов для этих объектов (Window, Cursor, Colormap и т. Д.), Которые в конечном итоге отображаются в простые целые числа. Мы все еще должны использовать эти имена типов при определении переменных, которые содержат дескрипторы по причинам переносимости.

### Выделение памяти для структур Xlib

Различные типы структур используются в интерфейсе `Xlib`. Некоторые из них определяются непосредственно пользователем. Другие определяются с использованием специальных функций `Xlib`. Это позволяет библиотеке правильно инициализировать эти структуры. Это очень удобно, так как в этих структурах, как правило, много переменных, что делают плохие программисты утомительную инициализацию. Из за своей гибкости `Xlib` сложен. Наличие значений по умолчанию позволит начинающему программисту X использовать библиотеку, не влияя на способность более опытного программиста настраивать эти миллионы параметров.

Что касается освобождения памяти, это делается одним из двух способов. В тех случаях, когда мы выделяем память - мы освобождаем ее таким же образом (т.е. используем `free()` для освобождения памяти, выделенной с помощью `alloc()`). В случае, если мы использовали какую-то функцию `Xlib` для ее выделения, или мы использовали какой-то метод запроса `Xlib`, который возвращает динамически выделенную память - мы будем использовать функцию XFree(), чтобы освободить этот блок памяти.

### События (Events)

Структура типа 'XEvent' используется для передачи событий, полученных от X-сервера. Xlib поддерживает большое количество типов событий. Структура XEvent содержит тип полученного события, а также данные, связанные с событием (например, положение на экране, где было сгенерировано событие, кнопка мыши, связанная с событием, область экрана, связанная с событием «перерисовка» и т. д. ). Способ чтения данных события зависит от типа события. Таким образом, мы можем иметь событие `XExpose`, событие `XButton`, событие `XMotion` и т. Д.

```Makefile
#Makefile
statr:
	g++ -o app win.cpp -lX11
```
